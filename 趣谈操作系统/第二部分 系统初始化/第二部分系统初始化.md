# 系统初始化

#### 系统初始化

各个职能部门（各个模块比如内存管理模块、中断初始化、调度模块初始化等）的创建；

用户态祖先进程的创建；

内核态祖先进程的创建。

![img](https://static001.geekbang.org/resource/image/cd/01/cdfc33db2fe1e07b6acf8faa3959cb01.jpeg)







#### 系统调用

系统调用是操作系统提供给程序设计人员使用系统服务的接口

系统调用流程

Linux 提供了 glibc 库, 它封装了系统调用接口, 对上层更友好的提供服务, 系统调用最终都会通过 DO_CALL 发起, 这是一个宏定义, 其 32 位和 64 位的定义是不同的
\- 32 位系统调用
  \- 用户态
   \- 将请求参数保存到寄存器
   \- 将系统调用名称转为系统调用号保存到寄存器 eax 中
   \- 通过软中断 ENTER_KERNEL 进入内核态
  \- 内核态
   \- 将用户态的寄存器保存到 pt_regs 中
   \- 在系统调用函数表 sys_call_table 中根据调用号找到对应的函数
   \- 执行函数实现, 将返回值写入 pt_regs 的 ax 位置
   \- 通过 INTERRUPT_RETURN 根据 pt_regs 恢复用户态进程

![img](https://static001.geekbang.org/resource/image/56/06/566299fe7411161bae25b62e7fe20506.jpg)

\- 64 位系统调用
  \- 用户态
   \- 将请求参数保存到寄存器
   \- 将系统调用名称转为系统调用号保存到寄存器 rax 中
   \- **通过 syscall 进入内核态**
  \- 内核态
   \- 将用户态的寄存器保存到 pt_regs 中
   \- 在系统调用函数表 sys_call_table 中根据调用号找到对应的函数
   \- 执行函数实现, 将返回值写入 pt_regs 的 ax 位置
   \- **通过 sysretq 返回用户态**

